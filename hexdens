#!/bin/sh
#! -*-perl-*-
eval 'exec perl -x -wS $0 ${1+"$@"}'
  if 0;

our $VERSION = '0.05';

=head1  NAME

B<hexdens> --  create density plots on a triangular or square lattice in postscript
or pdf format.

=head1  SYNOPSIS

usage: hexdens [options] F<infilename>

=head1 DESCRIPTION

hexdens writes color or grayscale density plots from input data on a
triangular lattice (or, optionally, a square lattice.) For the
triangular(square) lattice, each coordinate pair in the input file is covered
with a hexagon(square).  The output file format is PostScript or PDF. To run,
hexdens requires only a standard perl installation, which is present
on all Linux and nearly all Unix machines (Except if you want to
generate eps or pdf, in which case gs is required; see below.) Hexdens is a
single file that needs no compilation or installation.  It generates
its own documentation and parameter files.

The output file can be one of F<infilename.ps>, F<infilename.eps>, or
F<infilename.pdf>.  You need to have ghostscript installed in order to
write eps or pdf.  (All Linux and most Unix installations should have
ghostscript. It is available for MS platforms. If you can view a
PostScript document under Linux/Unix/MS Windows you almost certainly
have ghostscript installed as the backend. )  You may also use some
external conversion program to get pdf and eps if the files generated
by hexdens are not suitable.

Plotting options, (axes, labels, etc.) are controlled through command line options
or setting parameters in a parameter file. Type

hexdens -paramfile

to generate the file F<.hexdens> with the default parameters in the
current directory. Then edit this file to suit your needs. It will be
read each time hexdens is run.  This parameter file is heavily
commented. It contains the bulk of the documentation.  Any parameters
that are deleted from or 'commented out' of F<.hexdens> will be
determined by the builtin defaults.  If you copy F<.hexdens> to
F<infilename.p> and edit the result, then, only when processing data file
F<infile>, the file F<infilename.p> will be read
after F<.hexdens> and any parameters present will override previously
set values. Parameters set on the command line override all parameters
from files.

The program does not assume that the data is on a triangular grid--
the coordinates x,y can be any numbers. But a hexagon is drawn at the
coordinates of each data point in the input file, so that,
if a data point exists for each vertex of a
triangular lattice within a region, all space on the plot is filled
and no hexagons overlap.

The input data file should have lines of the form

 x y val

which causes a polygon with coloring representing val to be
drawn at the point x,y.  Numbers can be separated by whitespace (spaces,tabs)
or commas or anything not used to denote numbers (ie, digits
. + - e E). Leading whitespace
is ignored. Comment lines in the data file can start with the characters $ %  ;  ! .

This is  tested under Linux. It should work on MS systems,
if you install perl. ( and also ghostscript if you want eps or pdf) and
then probably  modify it somehow.

=head1 AUTHOR

John Lapeyre <lapeyre@physics.arizona.edu>

=head1 BUGS

Hexdens was written quickly to solve a particular need; as a result it
is missing features and may have bugs.  It has not been tested on a
wide range of tasks.

=head1 FILES

hexdens consists of a single file containing both the executable and
documentation.  hexdens can generate
documentation and a parameter file, .hexdens, to be read at
startup.

=head1 COPYRIGHT

Copyright 2003, John Lapeyre, All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.



=cut

=begin comment
   hexdens -- Programmers notes.
   An identifier begins with a capital letter if and only if it is 
   global (declared with 'our').
   Sections of this file and related groups of routines are separated
   by a bar like this '#==== ...'. 
   A block that serves only to implement scoping of variables to be shared
   by some routines is enclosed with bars like this '#*=*=*=* ...' .
   


=end comment

=cut 

#==========================================================================
# User parameters follow.

use strict;
use Getopt::Long;

our ($TRUE,$FALSE); 

# These are user settable parameters.
our ($ParameterList,$Plotwidth,$LandScape,$Xlo_cut,$Xhi_cut,$Ylo_cut,$Yhi_cut,
 $XTickStart,$XTickInt,$YTickStart,$YTickInt,@MagicIntervals,@Divisions,$UseColor,
 $XAxisLabel,$YAxisLabel,$Title,$LBound,$HBound,$TickInterval,$NumberOfSides,
 $LengthOfSide,$Rotation,$PSFormat,$BBPad,$TTick,$BTick,$LTick,$RTick,$PolyBorder,
 $TriHexDraw,$TriHexGray,$NumberPoly,$NumberPolyDig,$NumberPolySciLim,
 $NumberPolyZero,$NumberPolyGray,$NumberPolySciScale,$XAxis,$YAxis,
 $DataNorming,$DataTransformPower,$UseColTrans,$ColTransHi,$ColTransLo,
 $ShowNormalized,$DrawKey,$NumKeyBars,$Xbuf,$Ybuf,$Fontname,
 $Saturation,$Brightness,$KeyYOffset,$KeyXOffset,$KeyWidth,$KeyHeightScale,
 $XAxisLabelOffset,$YAxisLabelOffset,$Digits,$SciLim,$TickLabelOffset,
 $PolyLineWScale,$BoxLineWScale,$AxisLineWScale,$TickLineWScale,
 $TickLengthScale,$TickFontScale,$KeyFontScale,$AxisFontScale,
 $NumberPolyFontScale,$ExponentScale,$WriteBBox,
 $PostScriptInterpreter,$BBoxCommand );
 

=for comment
   The default values of the user parameters are set be eval'ing
 the string $ParameterList. This string can also be printed to 
 a file that can be edited and read, as well.

=cut 

BEGIN{

# True/False (binary) parameters use True=1, False=0.
$TRUE = 1;
$FALSE = 0;

our $ParameterList = <<'EOPARAMS';

# desired width of plot in inches, except for key and
# tick labels
$Plotwidth = 5;

#  Set to one to plot landscape
$LandScape = 0;

# plot range is done automatically if these are not defined
# These are ranges in units of input data

# ($Xlo_cut,$Xhi_cut,$Ylo_cut,$Yhi_cut); # declared here
# set them below
#$Xlo_cut = -20;
#$Xhi_cut = 25;
#$Ylo_cut = -20;
#$Yhi_cut = 20;

# Tick values are not determined automatically.
# These are the starting point and interval for ticks.
# Ticks are drawn both directions  from start point, till
# the edge of the plot is reached.
$XTickStart = 0;
$XTickInt = 3;
$YTickStart = 0;
$YTickInt = 3;

# List of "pleasing" intervals between ticks on graph.
# Only the first magnitude are listed, higher mags others are inferred:
@MagicIntervals = ( 1.0, 2.0, 2.5, 5.0, 10.0 );

# We'll choose from between 2 and 8 tick marks.
# Preference is given to more ticks:
@Divisions = (7,6,5);  # (include 8 ?)

# Use color or grayscale to denote data valeu
# color 1, grayscale 0
$UseColor = 1;  # 1 or 0

$XAxisLabel = "x";
$YAxisLabel = "y";
$Title = '  Title ';
#$Title = "";

$LBound = 'auto';
$HBound = 'auto';
$TickInterval = "auto";

# Select these to plot Hexagons
# Input x and y values for data should then be
#  points on a triangular lattice.
# If the lattice spacing on the triangular lattice is 1, then the
# correct hexagon has side length 1/sqrt(3), and is rotated 
# 30 degrees.
$NumberOfSides = 6;
#$LengthOfSide = 1/sqrt(3);
$LengthOfSide =   1/sqrt(3);
$Rotation = '30';

#$one_over_root_three = 1/sqrt(3);

# Select these to plot Squares. Input x and y values for data
# should then be points on a square lattice.
#$NumberOfSides = 4;
#$LengthOfSide = 1;
#$Rotation = '0';

# Whether to make ps, eps or pdf file.
# use  'ps', 'pdf', or 'eps'.
# This script alone will make ps files.
# if you set this for pdf or ps, you must have
# the ghostscript program installed. (See $WriteBBox
# below if it is not a standard installation)
$PSFormat = 'eps';

# pad the bounding box by this number of points
$BBPad = 20;

# Whether to draw ticks on L,R,B,T sides of frame
$TTick = 1;
$BTick = 1;
$LTick = 1;
$RTick = 1;

# If 1, draw a black border around each polygon
# as well as its density color.
$PolyBorder = 0;

# whether to draw underlying triangular lattice on Hexes
# 0 = don't draw
# 1 = draw only on hexes corresponding to data points
# 2 = draw triangular lattice over entire plot
$TriHexDraw = 0;
$TriHexGray = 0; # darkness of line (0=black, 1=white);

# whether to write the numeric data value inside the polygon
$NumberPoly=0;
# number of digits after decimal to write
$NumberPolyDig = 3;
# use sci. notation for abs(exponent) greater than this
$NumberPolySciLim = 2;
# set to zero to supress printing values equal to zero
$NumberPolyZero = 0;
# gray level for numbers (0=black, 1=white)
$NumberPolyGray = 0;
$NumberPolySciScale = .7;

# Whether to draw x and y axes.
$XAxis = 1;
$YAxis = 1;

# Data must be transformed into [0,1] for a density plot.
# This chooses how data values are mapped onto colors or gray values.
# If 'power' is chosen, set value of the power below.
# Notice that there is one more transform that maps the normed data in
# [0,1] onto a subinterval of [0,1]. This can be used to choose just
# subset of gray or color values, or to invert their meanings. These
# transform is set with $UseColTrans and $ColTransHi and $ColTransLo
$DataNorming = 'power';
#$DataNorming = 'linear';

# if taking root of data for plotting, use this power.
# If data is normalized between 0 and 1, a fractional power
# here will spread out the colors on the values near 1.
# If set to 1, the power will not be taken even if $DataNorming = 'power'.
$DataTransformPower = (1/2);

# parameters for linear transform of color/gray scale
# whether to do transform described below.
$UseColTrans = 1;

# maps normalized data values in [0,1]  into an subinterval
# of the color space (which is also  [0,1]. )
# This allows inversion or cutting out some
# colors. ColTransHi=1, ColTransLo=0 is the identity transform.
# reversing these inverts the color or grayscale.
# These numbers are the endpoints of the subinterval.
$ColTransHi =  0 ;
$ColTransLo =  .9;

# whether to show the normalized data, or raw data on key
# and in hexes. If set to zero, raw data values will be printed in
# the key. If set to 1, the linearly normalized data is show in the key.
# That is the effects of  power, log, color transform etc., are not
# shown on the plot.
$ShowNormalized = 1;

# Draw key to plot if = 1
$DrawKey = 1;

# number of colors/grays to show in key for plot
$NumKeyBars = 16;

# space between plot area and frame drawn around plot
# as fraction of plot width. It looks better with 0.05, or 0.1
$Xbuf = 0.07;
$Ybuf = 0.07;

# choose a font name.
$Fontname = 'Helvetica';
#$Fontname = 'Times';

# parameters applied to all colors. Colors are chosen with hue,saturation,
# brightness model. Hue encodes data value; the other two parameters
# are could be changed, but are probably best left at 1.
$Saturation = 1;
$Brightness = 1;

# Key is drawn flush with bottom right corner of plot, unless
# offsets are nonzero.
# $KeyYOffset is fraction of height of frame. So 0.1 will move it 1 tenth
# up the frame. $KeyXOffset is fraction of width of frame. So 0.07 means shift
# to the right by a distance 7% of the frame width.
# Key  height is  frame height times $KeyHeightScale.
# $KeyWidth is fraction of frame width.
$KeyYOffset = 0.0;
$KeyXOffset = 0.15;
$KeyWidth = 0.04;
$KeyHeightScale = 1.0;

# how far to move axis labels off of frame. As fraction of dimension of frame.
$XAxisLabelOffset = 0.07;
$YAxisLabelOffset = 0.05;

# The following two parameters currently only apply to 
# numbers printed in the key.
# How many digits to print to right of decimal in floating point numbers.
$Digits = 2;

# Max. absolute value of exponent before we switch to using scientific notation
# rather than ordinary decimal notation.
$SciLim = 1;

# Tick labels are drawn flush with frame unless this is non-zero.
# This gives a fraction of frame width to move labels away from frame.
$TickLabelOffset = 0.01;

# Default Line-widths/lengths will be multiplied by these numbers
$PolyLineWScale    = 1;  # scale linewidth of drawn polyborder
$BoxLineWScale     = 1;  # for frame around plot
$AxisLineWScale     = .5;  # for frame around plot
$TickLineWScale    = 1;  # for tick marks
$TickLengthScale  = 1;   # scale length of ticks
$TickFontScale    = 1;   # scale tick font
$KeyFontScale    = .8;   # scale numbers on color key
$AxisFontScale   = 1;  # scale labels on axes
$NumberPolyFontScale = .7; #number inside polygon
$ExponentScale   = 0.75; # scale down size of displayed exponent

# whether to put bounding box in file. This is required for
# eps and is a good idea for ps. But this will only work
# if you have ghostscript (or other PostScript interpreter)
# installed. 
# This is ignored if you choos $PSFormat = 'eps' or 'pdf'
$WriteBBox = 1;

# Command Name of PostScript interpreter 
# (probably gs for ghostscript)
$PostScriptInterpreter = 'gs';

# Computing the bbox for eps files would be a PITA.
# I assume a ghostscript interpreter is present and
# ask it to compute the bbox.
$BBoxCommand = $PostScriptInterpreter . 
    " -q -dNOPAUSE -dBATCH -sDEVICE=bbox ";


EOPARAMS

eval $ParameterList;

}   # end of BEGIN {

######## End of User Parameters.

#============================================================================

our $Verbose;
our $Initfilename = '.hexdens';
our $Infile;  # data file name
our $ScriptName = $0;

=for comment
  This prints some messages if the user has selected verbose mode.

=cut

sub verbose {
    my $mess = shift;
    print STDERR "$mess\n" if $Verbose;
}

=begin comment
  This block parses command line options and takes actions before
  and routines are executed.

=end comment

=cut

{

    my $shorthelp = <<"EOSHH";
Usage:
   hexdens [options] infilename
     Documentation options:
     -h        print this help message.
     -man      view documentation as  unix  man page.
     -mandoc  print documentation as man page to hexdens.1
     -textdoc  print documentation as plain text to standard output.
     -htmldoc  print documentation to  hexdens.html

     Other Options:
     -paramfile  write parameter template to the file .hexdens
     -color      make color density plot
     -gray|grey  make grayscale density plot
     -title="The Title"  plot title
     -v        verbose: print more messages during operation.
     -version  print hexdens version number and exit.
        infilename is the input data file
EOSHH

    $Verbose = 0;

    my %h = ( 'v' => \$Verbose ); # hash for options

    GetOptions( \%h, 'h', 'version', 'v', 'man', 'mandoc', 'htmldoc',
              'textdoc', 'paramfile', 
		'color', 'gray','grey', 'title=s');

# input data file name from command line
# other arguments are  already taken by GetOptions()
    $Infile = $ARGV[0];
    
    initialize();
    if ( exists $h{h} ) {
	print $shorthelp;
	exit(0);
    }
    if ( exists $h{version} ) {
	print "hexdens $VERSION\n";
	exit(0);
    }
    if ( exists $h{man}  ){
	my $res = `pod2man --help 2>&1 `;
        if ( defined $res and $res =~ /Usage/ ) {
	    system "pod2man $ScriptName | man -l - ";
	    exit(0);
	}
	else {
	    die "Can't find helper program pod2man (broken perl installation?) ";
	}
    }
    if ( exists $h{mandoc}  ){
	my $res = `pod2man --help 2>&1 `;
        if ( defined $res and $res =~ /Usage/ ) {
	    verbose "pod2man  $ScriptName hexdens.1";
	    system "pod2man  $ScriptName hexdens.1";
	    exit(0);
	}
	else {
	    die "Can't find helper program pod2man (broken perl installation?) ";
	}
    }
    if ( exists $h{textdoc}  ){
	my $res = `pod2text --help 2>&1 `;
        if ( defined $res and $res =~ /Usage/ ) {
	    system "pod2text $ScriptName ";
	    exit(0);
	}
	else {
	    die "Can't find helper program pod2text (broken perl installation?) ";
	}
    }
    if ( exists $h{htmldoc}  ){
	my $res = `pod2html --help 2>&1 `;
        if ( defined $res and $res =~ /Usage/ ) {
	    verbose "pod2html --outfile=hexdens.html  $ScriptName ";
	    system "pod2html --outfile=hexdens.html  $ScriptName ";
	    exit(0);
	}
	else {
	    die "Can't find helper program pod2text (broken perl installation?) ";
	}
    }
    if ( exists $h{paramfile} ) {
	verbose("Writing parameter file '$Initfilename'");
       open( OSTHAND , ">$Initfilename") or die
               "Can't open '$Initfilename' for writing.";
       print OSTHAND  parameter_prolog(),  $ParameterList;
       exit(0);
    }
    if ( exists $h{color} ) {
	$UseColor = 1;
    }
    if ( exists $h{gray} or exists $h{grey} ) {
	$UseColor = 0;
    }
    if ( exists $h{title} ) {
	$Title = $h{title};
    }


    if ( not defined $Infile or $Infile eq '' ){
	die "No input file specified; try option -h for help.";
    }



}

# parameter_prolog() returns a string containing text to print
# at the head of the parameter file .hexdens.
sub parameter_prolog {
    return << "EOPAR";
# Parameter file for hexdens. Set parameters here to
# override the default values. If you copy this file to
# datafile.p, where datafile is the name of the input data file,
# and that file will be read and will overwrite values set here.

# typing a comment symbol '#' in front of a line (or deleting it)
# will disable it,  and the corresponding parameter will take its
# default value, or the value set in the parameter file datafile.p

EOPAR
}

# use POSIX module for log10 and floor functions
use POSIX;


# names of output files
our $Psfile = "$Infile.ps";
our $Pdffile = "$Infile.pdf";
our $Epsfile = "$Infile.eps";

# sqrt(3)/2 to be written literally into the postscript code.
our $SST = sprintf("%.6f", sqrt(3)/2);

# string to redirect stderr to stdout.
our $Getstderr = ' 2>&1 1>/dev/null';

# $Xlo,$Xhi,$Ylo,$Yhi are limits of data set, computed
# on reading. $XBlo,$XBhi,$YBlo,$YBhi are the same with
# a buffers. See read_data() below.
our ($Xlo,$Xhi,$Ylo,$Yhi);
our ($XBlo,$XBhi,$YBlo,$YBhi);

# a few things that are written at the top of the PostScript file.
our ($DocTypeLine, $ShowPage, $PaperComments);

######################################

# ps command to switch colors; ps procedure to
# draw polygon; ps procedure for filling polygon
our (  $Setdensitycolor, $Polypath, $WhichFill );

# will be computed by gs and then inserted into file on second pass.
our $BoundingBox = '';

# debugging routine.
sub deb {
    my $s = shift;
#    print "$s\n";
}


#  initialize()  Read parameters from the files .hexdens
#    and infilename.p and eval the perl code therein.
sub initialize {
    if ( -e $Initfilename ) {
	verbose ("Reading parameters from '$Initfilename'");
	do $Initfilename;
    }
    else { verbose("Can't find parameter file '$Initfilename'");}
    if ( defined $Infile ) {
	my $pfile =  $Infile . "." . "p";
	if ( -e  $pfile ) {
	    do $pfile;
	verbose  "Reading parameters from '$pfile'"; 
	}
    }
}

# set_polygon_params() Some parametes set by the user
# just select a postscript procedure. Do this here.
# The strings that are set here are poscript commands or procedures.
sub set_polygon_params {
    if ( $UseColor == 1 ) {
	$Setdensitycolor = " $Saturation $Brightness sethsbcolor";
    }
    else {
	$Setdensitycolor = "setgray";
    }
    if ( $NumberOfSides == 6 ) {
	$Polypath = 'hexpoly';
    }
    elsif ( $NumberOfSides == 3 ) {
	$Polypath = 'trianglepoly';
    }
    elsif ( $NumberOfSides == 4 ) {
	$Polypath = 'squarepoly';
    }
    else {
	die "Only polygons with 3,4, or 6 sides are supported.";
    }
    
    if ( $PolyBorder == 1) {
	$WhichFill =  'polystfill';
    }
    elsif ( $PolyBorder == 0) {
	$WhichFill =  'polyfill';
    }
    else {
	die "\$WhichFill must be set to '0' or '1', not '$WhichFill'";
    }
} # end sub set_polygon_params {

#==========================================================================



# this block (context) is for scoping; 'my' variables defined in this block are 
# only visible to routines inside.
# Data taking and manipulation context
#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
{ 

# max and min of raw input data
 my ($max_v, $min_v);

# arrays containing, x,y,v points from data file.
# also @b contains data after normalizing and scaling with
# powers and color functions, etc. @nlin is the data only
# after the first linear mapping into [0,1].
# These are all visible to a handful of routines in this block.
 my (@xs,@ys,@v,@b,@nlin);

=begin comment
 read_data():
  input: $file  --  string containing data file name.
  output:  These are not returned, but are set in read_data.
        @xs, @ys @v -- arrays contianing triplets of numbers from each
                       line of data file.
        $max_v,$min_v,$Xlo,$Xhi,$Ylo,$Yhi -- max and mins of x,y,v calculate
                    as data file is read.
	$XBlo,$XBhi,$YBlo,$YBhi -- limits that are moved a bit farther apart
                     in order to provide a buffer for the plot frame.

=end comment

=cut

sub read_data {
    my $file = shift;  # data filename
    my $i = 0;
    my @nums; # temp storage for line of numbers.
    $max_v = undef;
    $min_v = undef;
    open INH , "<$file" or die "Can't open '$file' for reading.";
    while (<INH>) {
	next if /^\s*[\#\;\%\!]/;  # skip comments
# split fields on anything that is not part of a number
	@nums = split(/[^\.eE\d\+\-]+/, $_);
	$xs[$i] =  $nums[0];
	$ys[$i] =  $nums[1];
	$v[$i] =   $nums[2];
	$Xlo = $xs[$i] if not defined $Xlo;
	$Xhi = $xs[$i] if not defined $Xhi;
	$Ylo = $ys[$i] if not defined $Ylo;
	$Yhi = $ys[$i] if not defined $Yhi;
	
	$Xlo = $xs[$i] if $xs[$i] < $Xlo;
	$Ylo = $ys[$i] if $ys[$i] < $Ylo;
	$Xhi = $xs[$i] if $xs[$i] > $Xhi;
	$Yhi = $ys[$i] if $ys[$i] > $Yhi;
	
	$max_v = $v[$i] if not defined $max_v;
	$min_v = $v[$i] if not defined $min_v;
	$max_v = $v[$i] if $v[$i] > $max_v;
	$min_v = $v[$i] if $v[$i] <  $min_v;
	$i++;
    }

# Allow for width of hexes on edge
    $Xlo--;
    $Ylo--;
    $Xhi++;
    $Yhi++;
    
# override with  user supplied values if defined.
    $Xlo =  $Xlo_cut if defined $Xlo_cut;
    $Ylo =  $Ylo_cut if defined $Ylo_cut;
    $Xhi =  $Xhi_cut if defined $Xhi_cut;
    $Yhi =  $Yhi_cut if defined $Yhi_cut;

# add a bit of a buffer to data plotting area at 
# which frame will be drawn. So positions of text,
# etc will be drawn relative this expanded rectangle
    $XBlo = $Xlo - ($Xhi-$Xlo)*$Xbuf ;
    $XBhi = $Xhi + ($Xhi-$Xlo)*$Xbuf ;
    $YBlo = $Ylo - ($Yhi-$Ylo)*$Ybuf ;
    $YBhi = $Yhi + ($Yhi-$Ylo)*$Ybuf ;

    verbose "Finished reading data";
}  # end read_data()


sub do_norming {
    if ( $DataNorming eq 'linear' or
	 $DataTransformPower == 1 ) {
	norm_linear();
    }
    elsif ( $DataNorming eq 'power' ) {
	norm_power($DataTransformPower);
    }
    else {
	die '$DataNorming must be set to "linear" or "power"';
    }
}

sub norm_linear {
    my($i);
#    print "max $max_v, min $min_v\n";
    if ($max_v == $min_v ) {
	die "Zero range in data values!";
    }
    for ($i=0;$i<@xs;$i++) {
	$b[$i] = ($v[$i]-$min_v)/($max_v-$min_v);
	$nlin[$i] = $b[$i];
    }
}

sub inv_norm_linear {
    my $x = shift;
    return ($max_v-$min_v)*$x + $min_v;
}

sub norm_power {
    my $power = shift;
    my $i;
    norm_linear();
    for ($i=0;$i<@xs;$i++) {
	$b[$i]	 = $b[$i]**$power;
    } 
}

sub inv_norm_power {
    my $x = shift;
    return $x**(1/$DataTransformPower);
}

# hue value goes from 0 to 1. Normalized data goes from
# 0 to 1 . This is linear map of data into hue range
# in case we only want some of the color range.
sub all_scale_transform {
    my $i;
    for ($i=0;$i<@xs;$i++) {
	$b[$i]	= scale_transform($b[$i]);
    } 
}

sub scale_transform {
    my $x = shift;
    return $x * ($ColTransHi - $ColTransLo) + $ColTransLo;
}

sub inv_scale_transform {
    my $x = shift;
    return ($x-$ColTransLo) / ($ColTransHi - $ColTransLo);
}

sub norm_log {
    my ($max_b,$i);
    for ($i=0;$i<@xs;$i++) {
	$b[$i] = $v[$i]/$max_v; # normalize
	$b[$i] = -log($b[$i]);
	$max_b = $b[$i] if not defined $max_b;
#	$min_b = $b[$i] if not defined $min_b;
	$max_b = $b[$i] if $b[$i] > $max_b;
#	$min_b = $b[$i] if $b[$i] < $min_b;
    }
    for ($i=0;$i<@xs;$i++) {
	$b[$i] /= $max_b;
    }
}


sub make_data_postscript {
   my $i;
   my $str = '';
   for ($i=0;$i<@xs;$i++) { # plot the data
	if ( $NumberPoly == 1) {
	    if ( $ShowNormalized == 1) {
		$str .= pshexn( $xs[$i] ,  $ys[$i], $b[$i], $nlin[$i]  );
	    }
	    else {
		$str .= pshexn( $xs[$i] ,  $ys[$i], $b[$i], $v[$i]  );
	    }
	}
	else {
	    $str .= pshex( $xs[$i] ,  $ys[$i], $b[$i]  );
	}
    }
   return $str;
}

} # end  Data taking and manipulation context
#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=


sub format_real {
    my ($x,$dig,$scilim) = @_;
    my $r;
    my $s1 = sprintf("%.${dig}e",$x);
    $s1 =~ /e(.+)/; # find exponent
    die "Can't find exponent in conversion"
	unless defined $1;
    my $n = $1;
    if ( abs($n) <= $scilim) {
	$r = sprintf("%.${dig}f",$x);
    }
    else {
	return ($s1,1)
    }
    return ($r,0);
}

sub make_landscape_com {
    return <<"EOLL";
%-90 rotate -792 0 translate
90 rotate 0 -612 translate
/pagewidth 11 in def
/pageheight 8.5 in def
EOLL
}


sub set_initial_top_matter {
    $DocTypeLine = "%!PS-Adobe-2.0";
    $ShowPage = 'showpage';
    
$PaperComments = <<'EOPAP';

%%DocumentPaperSizes: letter
%%BeginSetup
[{
%BeginFeature: *PageRegion Letter
<</PageSize [612 792]>> setpagedevice
%EndFeature
} stopped cleartomark
%%EndSetup
EOPAP

} # emacs parser complains here, but it is wrong.


sub real_show {
    my $x = shift;
    my ($s,$flag) = format_real($x,$Digits,$SciLim);
    if ($flag == 0) {
	return "($s) show";
    }
    else {  return sci_not($s); }
}

# scientific notation with superscript
sub sci_not {
    my $n = shift;
    my ($mant,$exp) = split('e',$n);
    my $pe = sprintf("%d",$exp);
    return "($mant) ($pe) drawscinot";
}

sub pshex {
    my ($cx,$cy,$g) = @_;
    my $string;
    $string = sprintf("%f %.4e %.4e pd\n",$g,$cx,$cy);
    return $string;
}

sub pshexn {
    my ($cx,$cy,$g,$v) = @_;
    my $n = $NumberPolyDig;
    my ($str,$flag) = 
	format_real($v,$NumberPolyDig,$NumberPolySciLim);
#    if ( abs($v) < 1 and abs($v) > 0 ) { 
#	$s = sprintf("%.${n}f",$v);
#	$s =~ s/0//;  
#	print "$s\n";
#    }
#    else { 	$s = sprintf("%.2f",$v); }
    $str =~ s/^0//g;
    $str =~ s/0$//g;
    $str =~ s/e0/e/g;
    $str =~ s/e\-0/e\-/g;
    $str =~ s/0e/e/g;
    $str = '' if $str == 0 and $NumberPolyZero == 1;
    my $string;
    if ( $str =~ /e/ ) {
      $string = sprintf( "($str) %f %.6e %.6e pdnflsm\n",$g,$cx,$cy);
    }
    else {
      $string = sprintf("($str) %f %.6e %.6e pdnfl\n",$g,$cx,$cy);
    }
    return $string;
}


sub make_xticks  {
    my ($i, $x);
    my $s = '';
    return  $s unless $BTick == 1 || $TTick == 1;
    my @xticks = auto_ticks($Xlo,$Xhi,$LBound,$HBound,$TickInterval,
		  \@MagicIntervals, \@Divisions);
    my $nticks = scalar(@xticks);
    if ( $xticks[0] < $XBlo ) {
	shift(@xticks);
	$nticks--;
    }
    if ( $xticks[-1] > $XBhi ) {
	pop(@xticks);
	$nticks--;
    }
    my ($xpos,$xlpos);
    for ($i=0;$i< $nticks; $i++) {
	$xpos = $xlpos = $x = $xticks[$i];
	# adjust end ticks a bit
	$xlpos = "$x rtickfontheight 2 div sub" if $i == $nticks -1;
	$xlpos = "$x rtickfontheight 2 div add" if $i ==  0;
	$s .=  "($x) $xlpos yblo $xpos yblo drawbtick\n" if $BTick == 1;
	$s .=  "($x) $xlpos ybhi $xpos ybhi drawttick\n" if $TTick == 1;
    }
    return $s;
    $x = $XTickStart;
    for(;;) {
	$s .= "($x) $x yblo  drawbtick\n" if $BTick == 1;
	$s .= "($x) $x ybhi  drawttick\n" if $TTick == 1;
	$x -= $XTickInt;
	last if $x < $Xlo;
    }
    $x = $XTickStart + $XTickInt;
    for(;;) {
	last if $x > $Xhi;
	$s .= "($x) $x yblo  drawbtick\n" if $BTick == 1;
	$s .= "($x) $x ybhi  drawttick\n" if $TTick == 1;
	$x += $XTickInt;
    }
    return $s;
}


sub make_yticks  {
    my ($i, $y, $ypos, $ylpos);
    my $s = '';
    return unless $LTick == 1 || $RTick == 1;



    my @yticks = auto_ticks($Ylo,$Yhi,$LBound,$HBound,$TickInterval,
			    \@MagicIntervals, \@Divisions);

    my $nticks = scalar(@yticks);
    if ( $yticks[0] < $YBlo ) {
	shift(@yticks);
	$nticks--;
    }
    if ( $yticks[-1] > $YBhi ) {
	pop(@yticks);
	$nticks--;
    }

    for ($i=0;$i< $nticks; $i++) {
	$ypos = $ylpos = $y = $yticks[$i];
	# adjust end ticks a bit
	$ylpos = "$y rtickfontheight 2 div sub" if $i == $nticks -1;
	$ylpos = "$y rtickfontheight 2 div add" if $i ==  0;
	$s .=  "($y) xblo $ylpos xblo $ypos drawltick\n" if $LTick == 1;
	$s .=  "($y) xbhi $ylpos xbhi $ypos drawrtick\n" if $RTick == 1;
    }

    return $s;

    $y = $YTickStart;
    for(;;) {
	$s .=  "($y)  xblo $y drawltick\n" if $LTick == 1;
	$s .=  "($y) xbhi $y  drawrtick\n" if $RTick == 1;
	$y -= $YTickInt;
	last if $y < $Ylo;
    }
    $y = $YTickStart + $YTickInt;
    for(;;) {
	last if $y > $Yhi;
	$s .=  "($y) xblo $y  drawltick\n" if $LTick == 1;
	$s .=  "($y) xbhi $y  drawrtick\n" if $RTick == 1;
	$y += $YTickInt;
    }
    return $s;
}


sub  make_key_color_boxes {
    my $s = '';
    my ($i,$val);
    my @kb = (0..$NumKeyBars);
    my @kc = (0..$NumKeyBars);
    for($i=0;$i<$NumKeyBars;$i++) {
	$kc[$i] /= ($NumKeyBars-1);
	$kc[$i] = scale_transform($kc[$i]) if $UseColTrans == 1;
	$kb[$i] /= $NumKeyBars-1;
#	$kb[$i] = inv_scale_transform($kb[$i]) if $UseColTrans == 1;
	$kb[$i] = inv_norm_power($kb[$i]);
	$kb[$i] = inv_norm_linear($kb[$i]) if $ShowNormalized != 1;
#	print "col $kc[$i], val $kb[$i]\n";
    }

    $s = "gsave\n";
    for($i=0;$i<$NumKeyBars;$i++) {
        $val = sprintf("%.10e",$kb[$i]);
#	$val = format_real($kb[$i]);
	$val = real_show($kb[$i]);
	$s .=  <<"EOK"
 keyxpos keyypos $i keybarheight mul add moveto	
 0 keybarheight rlineto
 keywidth 0 rlineto
 0 keybarheight neg rlineto
 closepath
 $kc[$i]  $Setdensitycolor
 gsave
 fill
 grestore
 0 setgray stroke
 newpath
 keyxpos keywidth 1.2 mul add 
 keyypos $i .2 add keybarheight mul add moveto
 $val
EOK
  }    
    $s .= "grestore\n";
    return $s;
}

sub draw_axes {
    my $s = '';
    $s .= "drawxaxis\n" if $XAxis == 1;
    $s .= "drawyaxis\n" if $YAxis == 1;
    return $s;
}

sub make_title {
    my $st;
#    $st = "1  1.05  ($Title)  XCenterText";
    $st = print_centeredx($YBlo+1.05*($YBhi-$YBlo),$XBlo,$XBhi,$Title);
    return $st;
}

# Context for routines for showing text in mixed fonts
#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
{ 

    my $topstring;
    my $mainfont = "Mainfont";
    my $symfont = "MainSymbol";
    my $supfont = "MainSup";
    my $ssupfont = "MainSSup";
    my $supsymfont = "MainSupSym";
    my $subfont = "MainSub";
    my $subsymfont = "MainSubSym";
    my @fontlist;
    my %fontnums;

    my $fontsize;
    my $basefontname;

    my $rfontsize;
    my $supshift;
    my $ssupshift;
    my $subshift;

sub setup_mixed_fonts {
    my $boxwidth = $XBhi - $XBlo;

    $basefontname = $Fontname;
    $fontsize = .04 * $boxwidth;
#               0         1      2
     @fontlist = ($mainfont, $symfont, $supfont, 
#     3          4          5           6
   $supsymfont,$subfont, $subsymfont, $ssupfont);

%fontnums = ( 'rm' => 0, 'sym' => '1', 'rm^' => 2,
		 'sym^' => 3, 'rm_' => 4, 'sym_' => 5, 'rm^2' => 6 );
    
my $subscale = .65;
my $supscale = .65;
    
$rfontsize = 1.3;
$supshift = $fontsize /  $rfontsize * .7;
$ssupshift = $fontsize / $rfontsize * 1.1;
$subshift = - $fontsize / $rfontsize * .3;

     $topstring =  <<"EOL";

/$mainfont /$basefontname findfont $fontsize scalefont def
/$symfont /Symbol findfont $fontsize scalefont  def
/$supsymfont /Symbol findfont $fontsize $supscale mul  scalefont  def
/$supfont /$basefontname findfont $fontsize $supscale mul scalefont  def
/$ssupfont /$basefontname findfont $fontsize $supscale mul scalefont  def
/$subfont /$basefontname findfont $fontsize $subscale mul scalefont  def
/$subsymfont /Symbol findfont $fontsize $subscale mul  scalefont  def


EOL

}

####################
1;

sub make_font_declarations {
    return  $topstring;
}

sub parse_text_string {
    my $string = shift;
    my ($code,$txt);
    my @text = ();
    $string = '\rm ' . $string;
#    print STDERR "'$string'\n";
    while ($string ne '')  {
       $string =~ s/(\\[^\s]+)\s([^\\]+)//;
       if ( not defined $1 or not defined $2) {
	   die "Can't parse string.";
       }
#       print STDERR"Pair: '$1', '$2'\n";
       $code = $1; $txt = $2;
       $code =~ s/\\//;
       if (not exists $fontnums{$code}) {
	   die "Don't recognize font code '$code'";
       }
       push @text, $fontnums{$code};
       push @text, $txt;
    }
    return @text;
}

sub total_string_width {
    my @text = @_;
    my $outst = '';
    my ($i, $f, $st, $nextfont);
    for ($i=0;$i<@text;$i+=2) {
	$f = $text[$i];
	$st = $text[$i+1];
	$nextfont = $fontlist[$f];
	$outst .= "$nextfont setfont ($st) stringwidth pop\n";
    }
    for ($i=0;$i<@text/2-1;$i++) { $outst .= ' add ';}
    $outst .= " /totalstringwidth exch def\n";
    return $outst;
}

# sub show {}

sub print_centeredx {
    my($y,$Xlo,$Xhi, $text) = @_;
    my @text = parse_text_string($text);
    my ($i,$f,$nextfont,$st);
    my ($nsubshift,$nsupshift, $nssupshift) 
	= (-$subshift, -$supshift, -$ssupshift);
    my $outst = total_string_width(@text);
    my $xcent = ($Xlo+$Xhi)/2;
    $outst .= "$xcent totalstringwidth -2 div add $y moveto\n";
    for ($i=0;$i<@text;$i+=2) {
	$f = $text[$i];
	$st = $text[$i+1];
	$nextfont = $fontlist[$f];
	$outst .= " 0 $supshift rmoveto \n" if $f == 2 or $f == 3 ;
	$outst .= " 0 $ssupshift rmoveto \n" if $f == 7 or $f == 6 ;
	$outst .= " 0 $subshift rmoveto \n" if $f == 4 or $f == 5 ;
	$outst .= "$nextfont setfont ($st) show\n";
	$outst .= " 0 $nsupshift rmoveto \n" if $f == 2 or $f == 3 ;
	$outst .= " 0 $nssupshift rmoveto \n" if $f == 7 or $f == 6 ;
	$outst .= " 0 $nsubshift rmoveto \n" if $f == 4 or $f == 5 ;
    }
    return $outst;
}


sub print_underline {
    my($y,$Xlo,$Xhi) = @_;
    return " gsave .2 1 1 sethsbcolor $Xlo $y moveto $Xhi $y lineto stroke grestore\n";
}


} # end context for routines for showing text in mixed fonts
#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=


# context for routines that generate the PostScript code.
#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
{ 

# These strings contain PostScript code to 
my ( $keycolorboxes_com,  # create bars in key to plot
     $drawkey_com,        # draw the key
     $trihex_com,         # draw triangular lattice in hexes
     $alltrihex_com,      # draw triangular lattices in entire plot
     $landscape_com,      # render entire plot in landscape mode
     $font_declarations_com)
    = ('','','','','');

my ($prolog,$data,$yticks,$xticks,$title,$axes,$xlabel,$ylabel) = 
	('','','','','','','','','');

# These postscript commands are interspersed in the prolog.
sub create_interspersed_postscript {
    $keycolorboxes_com = make_key_color_boxes() if $DrawKey == 1;
    $drawkey_com = 'drawkey' if $DrawKey == 1;
    if ( $TriHexDraw ==  1 or  $TriHexDraw ==  2) {
	$trihex_com = 'pcx pcy trihex';
    }
    if (  $TriHexDraw ==  2) {
	$alltrihex_com = 'alltrihex';
    }
    if ( $LandScape == 1) {
	$landscape_com = make_landscape_com();
    }
    $font_declarations_com = make_font_declarations(); 
}


# must call create_interspersed_postscript above first.
sub set_prolog_string {
    $prolog = make_prolog($keycolorboxes_com,
	  $drawkey_com,$trihex_com,$alltrihex_com,$landscape_com,$font_declarations_com);
}

sub create_post_prolog_strings {

    $data = make_data_postscript(); 
    $yticks = make_yticks();
    $xticks = make_xticks();
    $title = make_title() if defined $Title and  $Title ne '';
    $axes = draw_axes();
    $xlabel = "($XAxisLabel) drawXaxislabel" if
        $XAxisLabel ne '';
    $ylabel = "($YAxisLabel) drawYaxislabel" if
        $YAxisLabel ne '';
}

sub make_entire_postscript_file {

my $string = <<"EPS";
$prolog
$alltrihex_com
$data
grestore  % pops clip path
drawbox
$axes
ticklabelfont setfont
$xticks
$yticks
$title
$xlabel
$ylabel
$drawkey_com
$ShowPage
%%EOF
EPS

    return $string;

}

#     
sub print_ps_file {
    my $outfile = shift;
    open PSH, ">$outfile" or die "Unable to open the file '$outfile' for writing";
    print PSH make_entire_postscript_file();
    close(PSH);
}  # end print_ps_file(...


}  # end context for routines that generate the PostScript code.
#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

# Create nearly all the postscript code.
sub prepare_ps_file {
    set_polygon_params();
    setup_mixed_fonts();
    set_initial_top_matter();
    create_interspersed_postscript();
    set_prolog_string();
    create_post_prolog_strings();
}

sub write_output {

    verbose "Writing output...";
    if ( $WriteBBox == 1 or $PSFormat eq  'eps' or $PSFormat eq  'pdf' ) {
	verbose "Pass 1";
	print_ps_file($Psfile . ".tmp");
	$BoundingBox = `$BBoxCommand $Psfile.tmp $Getstderr` ;
#    print STDERR "gs: '$BoundingBox'\n";
	chomp($BoundingBox);
	my @lines = split('\n',$BoundingBox) ;
	foreach (@lines) {
	    die "gs is failing to return bounding box"
		unless /^\%\%/;
	}
	my ($i, @outline);
	for($i=0;$i<2;$i++) {
	    my (@bnums) = split(/\s+/,$lines[$i]);
	    $bnums[3] += $BBPad;
	    $bnums[4] += $BBPad;
	    $bnums[1] -= $BBPad;
	    $bnums[2] -= $BBPad;
	    $outline[$i] = join(" ",@bnums);
	}
	$BoundingBox = $outline[0] . "\n" . $outline[1];
	$BoundingBox = "\n" . $BoundingBox ;
	if ( $PSFormat eq 'ps' ) {
	    set_prolog_string();
	    print_ps_file($Psfile);
	}
	if ( $PSFormat eq 'eps' ) {
	    verbose "Pass 2, writing eps";
	    $DocTypeLine = "%!PS-Adobe-3.0 EPSF-3.0";
	    $ShowPage = '';
	    $PaperComments='';
	    set_prolog_string();
	    print_ps_file($Epsfile);
	}
	if ( $PSFormat eq 'pdf' ) {
	    verbose "Pass 2, writing pdf";
	    set_prolog_string();
	    print_ps_file($Psfile . ".tmp");
	    system "gs -q -dBATCH -dNOPAUSE " .
		"-sOutputFile=$Pdffile -sDEVICE=pdfwrite $Psfile.tmp";
	}
    }
    else {
	print_ps_file($Psfile);
    }
}



# Print the PostScript Prolog and topmatter. This is the 
# bulk of the generated PostScript code.
sub make_prolog {

  my ($keycolorboxes_com,
      $drawkey_com,$trihex_com,$alltrihex_com,$landscape_com,$font_declarations_com) = @_;

my $string;

### A very long string follows
$string =  <<"TOPEOL";
$DocTypeLine$BoundingBox
%%Title: (Density plot of $Infile)
%%Creator: polydens
%%Orientation: Portrait
%%Pages: 1$PaperComments
%%Magnification: 1.0000
%%EndComments

% why do I need a namespace ?
%/PolyDensDict 200 dict def
%PolyDensDict begin

/in {72 mul} def  %  convert points to inches

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% assume letter size
/pagewidth 8.5 in def
/pageheight 11 in def

$landscape_com

% going to scale poly up from one point sides, so start with
% desired width of plot in points ( ie  points times inches)
/plotwidth $Plotwidth in def
% limits of data points  in poly units, ie physical units
/xlo $Xlo def
/xhi $Xhi def
/ylo $Ylo def
/yhi $Yhi def
% buffer around plot in polygon units
/ybuf $Ybuf def
/xbuf $Xbuf def

% length in plot units of poly side
/polysidelength $LengthOfSide def
% how much to rotate polygons
/polyrotation $Rotation def
% choose which polygon to draw
/whichpoly {
     $Polypath
} bind def


% factor to scale default polygon and plot boundary linewidths
% and fonts
/polylinescale $PolyLineWScale def
/boxlinescale $BoxLineWScale def
/ticklinescale $TickLineWScale def
/ticklengthscale $TickLengthScale def
/tickfontscale $TickFontScale def
/keyfontscale $KeyFontScale def
/axisfontscale $AxisFontScale def

% choose painting method
% fill or fill-and-stroke
/polypaint {
    $WhichFill
}  def


% plot limits with buffers around data
/xblo $XBlo def
/yblo $YBlo def
/xbhi $XBhi def
/ybhi $YBhi def

%/xblo xhi xlo sub xbuf mul xlo exch sub  def
%/xbhi xhi xlo sub xbuf mul xhi add  def
%/yblo yhi ylo sub ybuf mul ylo exch sub  def
%/ybhi yhi ylo sub ybuf mul yhi add  def

% dimensions of box in poly  units
/boxheight ybhi yblo sub def
/boxwidth  xbhi xblo sub def

% units of boxwidth
/bw { boxwidth mul } def
/bh { boxheight mul } def

% plotwidth and boxwidth both measure the same
% length, but in different units. plotwidth is in
% points (natural ps units), and boxwidth is in physical (data)
% units. We will rescale so that ps units are physical units
/polyscale plotwidth boxwidth div  def

/plotheight ybhi yblo  sub  xbhi xblo sub div
           plotwidth mul def
% center of box around plot in inches, relative
% to the origin for plotting data.
/ycent ybhi yblo add 2 div polyscale mul def
/xcent xbhi xblo add 2 div polyscale mul def
% center of US letter
% graphics origin is origin of data. Given this, we
% center plot. Except that labels and key are not included in computation
pagewidth 2 div  xcent sub pageheight 2 div  ycent sub translate

/polylinewidth 1 20 div polylinescale mul def
/boxlinewidth .002 bw boxlinescale mul def
/axislinewidth .002 bw $AxisLineWScale mul def
/ticklinewidth .002 bw ticklinescale mul def
/ticklength .01 bw  ticklengthscale mul def
/tickfontheight  .025 bw  tickfontscale mul def
/keyfontheight  .025 bw  keyfontscale mul def
/axislabelfontheight  .04 bw  axisfontscale mul def
/numberpolyfontheight .5 $NumberPolyFontScale mul def


$font_declarations_com
/ticklabelfont /$Fontname  findfont tickfontheight scalefont def 
/keyfont /$Fontname  findfont keyfontheight scalefont def 
/axislabelfont /$Fontname findfont axislabelfontheight scalefont def
/numberpolyfont /$Fontname  findfont numberpolyfontheight scalefont def 

% x point font is actually shorter than x points.
% dividing by this gives approximate height
/rfontheight 1.333 def

% 
/rtickfontheight tickfontheight rfontheight div def
/rkeyfontheight keyfontheight rfontheight div def
/rnumberpolyfontheight numberpolyfontheight rfontheight div def

%/ticklabeloffset boxwidth 60 div def
/ticklabeloffset $TickLabelOffset bw  def

/sst 3 sqrt 2 div def
/st  3 sqrt def

% choose one of setgray or sethsbcolor
/polyfill {
%    setgray
%    1 1 sethsbcolor
    $Setdensitycolor
    fill
} bind def


/Spolystfill {
    gsave
    currentpoint translate
    $Setdensitycolor
    hexpoly ufill
    0 setgray 
    hexpoly ustroke
    grestore
} bind  def

/polystfill {
    gsave
    polyfill
    grestore
    0 setgray 
    stroke
} bind  def


% This draws the polygon
/Spd {
    /pcy exch def
    /pcx exch def    
    gsave
    newpath
    pcx pcy moveto % move to center of poly
    polysidelength polysidelength  scale
    polyrotation rotate	
    polypaint
    grestore
    $trihex_com
} def

% This draws the polygon
/pd {
    /pcy exch def
    /pcx exch def    
    gsave
    newpath
    pcx pcy moveto % move to center of poly
    polysidelength polysidelength  scale
    polyrotation rotate	
    whichpoly  % add poly sides to path
    closepath
    polypaint
    grestore
    $trihex_com
} def

/pdnsci {
  /polycy exch def
  /polycx exch def
  polycx polycy pd
  polycx polycy numberpolysci % pop 2
} def

/pdnfl {
  /polycy exch def
  /polycx exch def
  polycx polycy pd
  polycx polycy  numberpoly  % pop 1
} def

/numberpoly {
 gsave
 numberpolyfont setfont
 moveto
 dup
 stringwidth pop
 2 div  neg  rnumberpolyfontheight 2 div  neg  rmoveto
 $NumberPolyGray setgray
 show
 grestore
}def

% smaller version
/pdnflsm {
  /polycy exch def
  /polycx exch def
  polycx polycy pd
  polycx polycy  numberpolysm  % pop 1
} def

%
/numberpolysm {
 gsave
 numberpolyfont setfont
 moveto
 $NumberPolySciScale  $NumberPolySciScale  scale
 dup
 stringwidth pop
 2 div  neg  rnumberpolyfontheight 2 div  neg  rmoveto
 $NumberPolyGray setgray
 show
 grestore
}def

/numberpolysci {
 gsave
 moveto
 exch
 dup
 stringwidth pop
 div 2 neg 0 rmoveto
 0 setgray
 exch
 drawscinot
 grestore
}def

/Shexpoly {
    ucache
    -1 -$SST 1 $SST setbbox
    0 0 moveto
    .5 $SST rmoveto
    .5 -$SST  rlineto
    -.5 -$SST  rlineto
    -1  0  rlineto
    -.5 $SST rlineto
    .5  $SST rlineto
} cvlit def


/hexpoly {
    .5 //sst rmoveto
    .5 //sst neg rlineto
    -.5 //sst neg rlineto
    -1  0  rlineto
    -.5 //sst rlineto
    .5  //sst rlineto
} bind def

% draw triangular lattice lines on top of
% hexagons.
/trihex {
   gsave
   newpath
   moveto
   currentpoint translate
   polysidelength polysidelength  scale
   polyrotation rotate	    

   0 //sst moveto
   0 //sst neg lineto
   0 0 moveto
   60 rotate
   0 //sst moveto
   0 //sst neg lineto
   60 rotate
   0 //sst moveto
   0 //sst neg lineto

   closepath
   currentlinewidth .3 mul setlinewidth
   $TriHexGray setgray stroke
   grestore
} bind def

% draw triangular lattice over entire plot
% clipping path is set, however.
/bwidth xbhi xblo sub def
/bheight ybhi yblo sub def

/alltrihex {
   gsave
   newpath
   0 0 moveto
   30 rotate
   3 { % repeat
    0 1.5  $LengthOfSide mul  //xbhi //bwidth add    {
       dup
       0 moveto
       0 //ybhi //bheight add rmoveto
       0 //ybhi //bheight add 2 mul neg rlineto
       neg
       0 moveto
       0 //ybhi //bheight add rmoveto
       0  //ybhi //bheight add 2 mul neg rlineto
    } for
    60 rotate  
   } repeat
   closepath
   currentlinewidth .3 mul setlinewidth
   $TriHexGray setgray stroke
   grestore
} def


/trianglepoly {
    0 1 st div rmoveto
    .5 //sst neg  rlineto
    -1 0 rlineto
} bind def

/squarepoly {
    .5 .5 rmoveto
    0 -1  rlineto
    -1 0 rlineto
    0  1 rlineto
} bind def 


/drawbox {
    gsave
    boxlinewidth setlinewidth
    newpath
    xblo yblo moveto
    xblo ybhi lineto
    xbhi ybhi lineto
    xbhi yblo lineto
    closepath
    0 setgray
    stroke
    grestore
} def

/drawxaxis {
   gsave
   axislinewidth setlinewidth
   newpath
   xblo 0 moveto
   xbhi 0 lineto
   [ .02 bw .01 bw  ] 0 setdash
   stroke
   grestore
} def

/drawyaxis {
   gsave
   axislinewidth setlinewidth
   newpath
   0 yblo  moveto
   0 ybhi  lineto
   [ .02 bw .01 bw  ] 0 setdash
   stroke
   grestore
} def

% draw tick at bottom
/drawbtick {
    gsave
    ticklinewidth setlinewidth
    /ytick exch def
    /xtick exch def
    /labytick exch def
    /labxtick exch def
    newpath
    xtick ytick moveto
    0 ticklength rlineto
    labxtick labytick moveto
    dup   % label
    stringwidth pop
    neg 2 div   rtickfontheight neg 
          ticklabeloffset sub  rmoveto
%    neg 2 div   0  rmoveto
    show  % pop label
    closepath
    0 setgray
    stroke
    grestore
} def

% draw tick at bottom
/drawttick {
    gsave
    ticklinewidth setlinewidth
    /ytick exch def
    /xtick exch def
    /labytick exch def
    /labxtick exch def
    newpath
    xtick ytick moveto
    0 ticklength neg rlineto
    labxtick labytick moveto
    dup   % label
    stringwidth pop
%    neg 2 div   tickfontheight 1.2 div  rmoveto
    neg 2 div   ticklabeloffset  rmoveto
    show  % pop label
    closepath
    0 setgray
    stroke
    grestore
} def

% draw tick at left
/drawltick {
    gsave
    ticklinewidth setlinewidth
    /ytick exch def
    /xtick exch def
    /labytick exch def
    /labxtick exch def
    newpath
    xtick ytick moveto
    ticklength 0 rlineto
    labxtick labytick moveto
    dup   % label
    stringwidth pop
    neg  ticklabeloffset sub tickfontheight neg 3 div  rmoveto
%    neg  0   rmoveto
    show  % pop label
    closepath
    0 setgray
    stroke
    grestore
} def

% draw tick at right
/drawrtick {
    gsave
    ticklinewidth setlinewidth
    /ytick exch def
    /xtick exch def
    /labytick exch def
    /labxtick exch def
    newpath
    xtick ytick moveto
    ticklength neg 0 rlineto
    labxtick labytick moveto
%    ticklabeloffset add tickfontheight neg 3 div  rmoveto
    ticklabeloffset tickfontheight neg 3 div  rmoveto
%    neg  0   rmoveto
    show  % pop label
    closepath
    0 setgray
    stroke
    grestore
} def

% draw some text centered and paraellel to x-axis
/XCenterText {
  /Text exch def
  /Position exch def
  /TextScale exch def
  gsave
  0 setgray
  /$Fontname findfont .04 bw TextScale mul  scalefont setfont
  newpath
  xbhi xblo add  2 div
  yblo Position bh add
  moveto
  Text stringwidth  pop neg 2 div 0 rmoveto
  Text show  
  grestore
} def

/drawXaxislabel {
 /Xlabel exch def
 gsave
 newpath
 axislabelfont setfont
 0 setgray
 xbhi xblo add  2 div
 yblo boxwidth $XAxisLabelOffset mul sub
 moveto
 Xlabel stringwidth  pop neg 2 div 0 rmoveto
 Xlabel show
 grestore
} def

/drawYaxislabel {
 /Ylabel exch def
 gsave
 newpath
 axislabelfont setfont
 0 setgray
 xblo boxwidth $YAxisLabelOffset mul sub
 ybhi yblo add  2 div
 moveto
 Ylabel stringwidth  pop neg  0 rmoveto
 Ylabel show
 grestore
} def


/drawscinot {
  /exponent exch def
  /mantissa exch def
  (A) stringwidth pop dup
  /charsh exch .4 mul def
  /dotrad exch .1 mul def
  mantissa show 
  charsh  .4 rkeyfontheight mul rmoveto 
  gsave 1.5 1.5 scale 
  currentpoint dotrad 0 360 arc fill
%  (.) show 
  grestore
  0  -.4 rkeyfontheight mul rmoveto 
  charsh 2 div 0 rmoveto (10) show
%  mantissa stringwidth pop
%  .8 rfontheight mul rmoveto
  0  .6 rkeyfontheight mul rmoveto
  gsave   
  $ExponentScale $ExponentScale scale
  exponent show
  grestore
} def

/keywidth $KeyWidth bw  def
/keyheight boxheight $KeyHeightScale mul def
/keylinewidth boxlinewidth def
/numkeybars $NumKeyBars def

/keybarheight keyheight numkeybars div def
/keyxpos $KeyXOffset bw  xbhi add  def
%/keyypos ybhi yblo add 2 div def
/keyypos  yblo $KeyYOffset bw add  def

/drawkey {
  gsave
  keyfont setfont
  keylinewidth setlinewidth
  keyxpos keyypos moveto
  0 setgray
  0 keyheight rlineto
  keywidth 0  rlineto
  0 keyheight neg rlineto
  closepath
  stroke
  $keycolorboxes_com
  grestore
} def

%%EndProlog

% set scale so ps units = input data units
polyscale polyscale scale
polylinewidth setlinewidth

% clip off data that lies outside our range
gsave
newpath
xlo ylo moveto xlo yhi lineto xhi yhi lineto
xhi ylo lineto closepath clip
ticklabelfont setfont


TOPEOL

return $string;
}  # end sub make_prolog

#============================================================================

=begin comment
 Routines for computing ticks; These routines are independent of the
 rest of the program. These routines are a perl translation 
 (and modification) of  Numeric Python routines. The python routines carry
 the following copyright notice.

#--------------------------------------------------------------------------------
#
#  Helper functions for calculating axis tick related values (i.e. bounds and
#  intervals)
#  Written by: David C. Morrill (based on similar routines written by Eric Jones)
#
#  Date: 07/10/2002
#
#  (c) Copyright 2002 by Enthought, Inc.
#
#--------------------------------------------------------------------------------

=end comment

=cut

=begin comment

Find locations for axis tick marks.

Calculate the location for tick marks on an axis. data_low and data_high
specify the maximum and minimum values of the data along this axis.
bounds_low, bound_high and tick_intervalspecify how the axis end points
and tick interval are calculated. An array of tick mark locations is
returned from the function.  The first and last tick entries are the
axis end points.

        data_low,   The maximum and minimum values of the data long this axis.
        data_high:  If any of the bound settings are 'auto' or 'fit', the axis
                    traits are calculated automatically from these values.
        bound_low:  Can be 'auto', 'fit' or a number.
        bound_high: If a number,the axis trait is set to that value.  If the
                    value is 'auto', the trait is calculated automatically.
                    The value can also be 'fit' in which case the axis end
                    point is set equal to the corresponding data_low/data_high
                    value.
        tick_interval: Can be 'auto' or a positve number specifying the length
                    of the tick interval, or a negative integer specifying the
                    number of tick intervals.

        $magic_arr, $division_arr.  References to arrays. magic_arr is the list of
                    numbers that can be the basic tick interval. Only the mantissa is
		    given in this list. division_arr is a list of possible numbers of
		    ticks. (I think the max+1 and min-1 are also possible.) auto_interval
		    routine picks the mantissa and number of ticks pair that most nearly
		    fills the data window with ticks.

=end comment

=cut

sub auto_ticks {
    my ($data_low, $data_high, $bound_low, $bound_high, $tick_interval, $magic_arr,
	$division_arr )
	=@_;

    my ( $rng, $intervals, $FALSE,  $delta, $auto_lower, $auto_upper,
	 $start,$end,@ticks, $is_auto_low, $is_auto_high,$lower,$upper);
	 
    my ($i);

    $FALSE = ( 1 == 0 );

    $is_auto_low  = ($bound_low  eq 'auto');
    $is_auto_high = ($bound_high eq 'auto');

    if ( $bound_low ne 'auto'  and $bound_low ne 'fit') {
	$lower = $bound_low;
    }
    else {
	$lower = $data_low;
    }

    if ( $bound_high ne 'auto'  and $bound_high ne 'fit') {
	$upper = $bound_high;
    }
    else {
	$upper = $data_high;
    }
#    print STDERR "chose one '$tick_interval'\n";
    if (( $tick_interval eq 'auto') or ($tick_interval == 0.0)){
	$rng = abs( $upper - $lower );
	if ($rng == 0.0) {
	    $tick_interval = 0.5;
	    $lower   = $data_low  - 0.5;
            $upper   = $data_high + 0.5;
	}
	if (is_power_2( $rng ) and is_power_2( $upper ) and $rng > 4) {
	    if ($rng == 2) {
		$tick_interval = 1;
	    }
	    elsif ($rng == 4) {
		$tick_interval = 4;
	    }
	    else {
		$tick_interval = $rng / 4;   # maybe we want it 8?
	    }
	}
	else {
#	    deb "entering auto interval";
	    $tick_interval = auto_interval( $lower, $upper, $magic_arr, $division_arr );
	}
    }
    elsif( $tick_interval < 0) {
	$intervals     = -$tick_interval;
	$tick_interval = tick_intervals( $lower, $upper, $intervals );
#	print STDERR "chose $tick_interval\n";
	if ($is_auto_low and $is_auto_high) {
	    $is_auto_low = $is_auto_high = $FALSE;
	    $lower = $tick_interval * floor( $lower / $tick_interval );
	    while ( ((abs( $lower ) >= $tick_interval) and
		     (($lower + $tick_interval * ($intervals - 1)) >= $upper))) {
		$lower -= $tick_interval;
	    }
	    $upper = $lower + $tick_interval * $intervals;

	}
    }

    # If the lower or upper bound are set to 'auto', 
    # calculate them based on the newly chosen $tick_interval:
    if ( $is_auto_low or $is_auto_high) {
	$delta = 0.01 * $tick_interval * ($data_low == $data_high);
	deb "delta $delta";
	deb "tick interval $tick_interval, $data_low, $data_high";
	($auto_lower, $auto_upper) = auto_bounds( $data_low - $delta, $data_high + $delta,
						$tick_interval );
	if ( $is_auto_low) {
	    $lower = $auto_lower;
	}
	if ( $is_auto_high) {
	    $upper = $auto_upper;
	}
	deb "got autlower $auto_lower";	
    }
    deb "got lower $lower";

    
    # Compute the range of ticks values:
    $start = floor( $lower / $tick_interval ) * $tick_interval;
    $end   = floor( $upper / $tick_interval ) * $tick_interval;
    if ( $upper > $end) {
	$end += $tick_interval;
    }
#    print "start $start, end: " , $end + ($tick_interval / 2.0), 
#     " interval: $tick_interval" ."\n";
#  use < end or <= end ?
    for($i=$start;$i<$end + ($tick_interval / 2.0); $i+=$tick_interval) {
	push @ticks,$i;
    }
#    deb "after bounds2";
#    @ticks = arange( $start, $end + ($tick_interval / 2.0), $tick_interval );

    if ( scalar(@ticks)  < 2) {
	@ticks = array( ( ( $lower - $lower * 1.0e-7 ), $lower ) );
    }
    if ( $bound_low eq 'fit') {
	$ticks[0] = $lower;
    }
    if ( $bound_high eq 'fit') {
	$ticks[-1] = $upper;
    }

#    print "data_low $data_low, data_high $data_high: ";
#    for($i=0;$i<@ticks;$i++) {
#	print $ticks[$i], ", ";
#    }
#    print "\n";

    return @ticks;
}

# return true if $n is a power of two
sub is_power_2 {
    my $n = shift;
    return 1 if (($n) & ($n-1)) == 0;
    return 0;
}

#--------------------------------------------------------------------------------
#  Compute the best tick interval for a specified data range:
#--------------------------------------------------------------------------------

=begin comment

       Calculate the tick intervals for a graph axis.

        Description:        
        The boundaries for the data to be plotted on the axis are:
            data_bounds = (lower,upper)

        A choice is made between 3 to 9 ticks marks (including end points)
        and tick intervals at 1, 2, 2.5, 5, 10, 20, ...

        Returns:
        interval -- float. tick mark interval for axis            

=end comment

=cut

sub  auto_interval {
    my ( $data_low, $data_high, $magic_intervals, $divisions ) = @_;

    my ($i,$j);
    my($range, @candidate_intervals,@magnitudes,
       @mantissas,  $min_difference, $min_index,
       $differences, $magnitude, $interval, $result,  $min_mag_index,  $min_man_index
       );
    $range = $data_high  -  $data_low ;



#    divisions = arange( 8.0, 2.0, -1.0 ) # ( 7, 6, ..., 3 )
    
    # Calculate the intervals for the divisions:
    @candidate_intervals = @$divisions;
    foreach (@candidate_intervals) { $_ = $range/$_; }
#    candidate_intervals = $range / divisions
    
    # Get magnitudes and mantissas for each candidate:
    @magnitudes = @candidate_intervals;

    foreach( @magnitudes ) { $_ = 10.0 ** floor( log10($_ ) )}
    for($i=0;$i<@magnitudes;$i++) {
	$mantissas[$i] = $candidate_intervals[$i]/$magnitudes[$i];
    }

#    magnitudes = 10.0 ** floor( log10( candidate_intervals ) )
#    mantissas  = candidate_intervals / magnitudes
    
    
    # Calculate the absolute differences between the candidates
    # (with magnitude removed) and the magic intervals:
#    differences = abs( Magic_intervals[:,NewAxis] - mantissas ) 

    # Find the division and magic interval pair that produces the
    # smallest differences:
    $min_difference = 1e6;  # mantissas are less than a million
    my $tmpdiff ;
    for($i=0;$i<@mantissas;$i++) {
	for($j=0;$j<@$magic_intervals;$j++) {
	    $tmpdiff = abs($$magic_intervals[$j]-$mantissas[$i]);
#	    print "$tmpdiff\n";
	    if ($tmpdiff < $min_difference) {
		$min_difference = $tmpdiff;
		$min_mag_index = $j;
		$min_man_index = $i;
	    }
	}
    }
    # The best interval is the magic_interval multiplied by the magnitude
    # of the best mantissa:
    $interval  = $$magic_intervals[$min_mag_index];
    $magnitude = $magnitudes[$min_man_index];
    $result    = $interval * $magnitude;
#    deb "int and mag '$interval', $magnitude";
#    deb "got result: interval $result";

    if ( $result == 0.0 ) {
	$result = 1e-12;
    }

    return $result;
}

           
#--------------------------------------------------------------------------------
#  Compute the best tick interval length to achieve a specified number of tick
#  intervals:
#--------------------------------------------------------------------------------

sub  tick_intervals {
    my ( $data_low, $data_high, $intervals ) = @_;
    
    my($range, $interval,$factor, $index, @tmparray, $result );
    $range   =  $data_high - $data_low;
    
    if (  $range == 0.0) {
	$range = 1.0;
    }
    $interval  = $range / $intervals;
    $factor    = 10.0 ** floor( log( $interval )/log(10) );
    $interval /= $factor;
    if ( $interval < 2.0) {
	$interval = 2.0;
	$index    = 0;
    }
    elsif ( $interval < 2.5) {
	$interval = 2.5;
	$index    = 1;
    }
    elsif ( $interval < 5.0){
	$interval = 5.0;
	$index    = 2;
    }
    else {
	$interval = 10.0;
	$index    = 3;
    }
    @tmparray = ( 2.0, 1.25, 2.0, 2.0 );
    for(;;) {
#	print "Entered for\n";
	$result = $interval * $factor;
	if ( ((floor( $data_low / $result ) * $result) + ($intervals * $result) >=
	      $data_high)) {
	    return $result;
	}
	$index     = ($index + 1) % 4;
        $interval *= $tmparray[ $index ];
    }
}
           
#--------------------------------------------------------------------------------
#  Compute the best lower and upper axis bounds for a range of data:
#--------------------------------------------------------------------------------

sub auto_bounds {
    my( $data_low, $data_high, $tick_interval ) = @_;

=begin comment

    Calculate an appropriate upper and lower bounds for the axis from
    the the data_bounds (lower, upper) and the given axis interval.  The
    boundaries will either hit exactly on the lower and upper values
    or on the tick mark just beyond the lower and upper values.

=end comment

=cut


    return ( calc_bound( $data_low,  $tick_interval, $FALSE ),
             calc_bound( $data_high, $tick_interval, $TRUE  ) );
}       

#--------------------------------------------------------------------------------
#  Compute the best axis endpoint for a specified data value:
#--------------------------------------------------------------------------------

sub calc_bound {
    my( $end_point, $tick_interval, $is_upper ) = @_;

=begin comment

        Find an axis end point that includes the value 'end_point'.  If the
        tick mark interval results in a tick mark hitting directly on the 
        end_point, end_point is returned.  Otherwise, the location of the tick
        mark just past the end_point is returned. end is 'lower' or 'upper' to
        specify whether end_point is at the lower or upper end of the axis.

=end comment

=cut

    my($quotient,$remainder,$c1,$c2);
    $quotient = floor($end_point/$tick_interval);
#    print STDERR "$end_point, $tick_interval\n";
    $remainder = $end_point  - $quotient * $tick_interval;
#    print STDERR "end $end_point, q $quotient, r $remainder\n";
    if ( (($remainder == 0.0) or
	  ((($tick_interval - $remainder) / $tick_interval) < 0.00001))) {
	return $end_point;
    }
    $c1 = ($quotient + 1.0) * $tick_interval;
    $c2 = $quotient         * $tick_interval;
#    deb "c1 $c1, c2 $c2";
    if ( $is_upper ) {
	return $c1 if $c1 > $c2;
	return $c2;
#	return max( $c1, $c2 );
    }
    return $c1 if $c1 < $c2;
    return $c2;
#    return min( $c1, $c2 );
}

# End routines to compute tick marks
#============================================================================


###########################################
# Call the routines to do all the work.

read_data($Infile);
do_norming();
all_scale_transform() if $UseColTrans == 1;
prepare_ps_file();
write_output();

